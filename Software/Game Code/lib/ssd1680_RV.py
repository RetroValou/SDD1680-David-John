"""
Â© Anastase Valentin, 2024. All rights reserved.

This code is protected by copyright law. Unauthorized copying, distribution, or modification
of this code, in part or in whole, is strictly prohibited without prior written consent
from the copyright owner.
"""

"""
In reality, I would never bother you if you want to tinker, reuse, or do whatever you want with the code.
It's just to protect the ability to sell the console or to design the David & John console while being protected against big companies.
It would be surprising to have such success, but you never know

If you are an individual or a small business, you can reuse the code for products to sell as long as you contribute something.
This is applicable for all codes!
Not just copy-paste all my code to make another David & John console with the same games!
"""

""" Show my Itch.io page for see my other games ! https://retrovalou.itch.io """


from machine import Pin, ADC, SPI
from time import sleep
from gc import mem_alloc, mem_free, collect
from json import load
from utime import ticks_ms

def monotonic():
    return ticks_ms() / 1000

try:
    from game_basic_fct import exc_wit_busy, start_exc_wit_busy
except :
    print("error")
    def exc_wit_busy():
        return
    def start_exc_wit_busy():
        return
    
debug_mode = False
print_text = False
Test_only_speed = False


# LUT for a single colour refresh, obtained from WaveShare
lut_black = [
0x80,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x10,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
0x80,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x10,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x06,0x00,0x00,0x00,0x00,0x01,
0x0A,0x0A,0x00,0x0A,0x0A,0x00,0x00,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x08,0x00,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x44,0x44,0x44,0x44,0x44,0x44,0x00,0x00,0x00]

lut_clean = [
0x90,0x90,0x60,0x80,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x60,0x90,0x60,0x80,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x90,0x60,0x60,0x80,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x60,0x90,0x60,0x80,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x02,0x00,0x00,0x00,0x00,0x01,
0x02,0x02,0x00,0x00,0x00,0x00,0x00,
0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x02,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x66,0x66,0x66,0x66,0x66, #0x44
0x00,0x00,0x00]

lut_long = [
0x84,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x84,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
0x84,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
0x84,0x66,0x99,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x04,0x00,0x00,0x4B,0x00,0x00,0x03,
0x08,0x08,0x00,0x00,0x00,0x00,0x04,
0x06,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x44,0x44,0x44,0x44,0x44,0x44,0x00,0x00,0x00]


def update_lut_by_temperature():
    global temperature
    global lut_partial_grey
    global Lut_choose
    global lut_diff
    global lut_partial
    global lut_partial_only_black
    adc = ADC(4) 
    analog_value = adc.read_u16()
    voltage = analog_value * (3.3 / 65535.0)
    temperature = 27 - (voltage - 0.706) / 0.001721 + 2 # More accurate with battery
    
    Lut_choose = 0
    if(temperature < 20):
        Lut_choose = 1
        lut_diff = [
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, # LUT 0  -> 0 - 0 / black / GND
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAA, # LUT 1  -> 0 - 1  / black to white / A = VSL (-)
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55, # LUT 2  -> 1 - 0 / white to black / A = VSH1 (+)
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80, # LUT 3  -> 1 - 1  / white / GND, at end VSL (-)
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, # LUT 4  -> ? - ?
            0x01,0x01,0x00,0x00,0x00,0x00,0x05, # G 0  / T A = 1  T B = 1  / Reapeat 5 Times
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, # G 1  / T A = 1  / no repeat
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 2  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 3  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 4  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 5  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 6  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 7  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 8  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 9  / Skip
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, # G 10  / Skip
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, # G 11  / T A = 1  / no repeat
            0x77,0x77,0x77,0x77,0x77,0x77, # 0x7 Frequency
            0x00,0x00,0x00] # XON0 
        lut_partial_grey = [
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x08,0x06,0x00,0x00,0x00,0x00,0x00, 
            0x06,0x04,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x77,0x77,0x77,0x77,0x77,0x77, 
            0x00,0x00,0x00]
        lut_partial_only_black = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x01,0x00,0x00,0x00,0x00,0x05, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x77,0x77,0x77,0x77,0x77,0x77, 
            0x00,0x00,0x00] 
        lut_partial = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x99, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x01,0x00,0x00,0x00,0x00,0x05, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x77,0x77,0x77,0x77,0x77,0x77, 
            0x00,0x00,0x00]   
    elif(temperature < 30):
        Lut_choose = 2
        lut_diff = [
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0xA0,0xA0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0, 
            0x50,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x01,0x00,0x00,0x00,0x00,0x04, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88, 
            0x00,0x00,0x00] 
        lut_partial_grey = [
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90, 
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90, 
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x08,0x06,0x00,0x00,0x00,0x00,0x00, 
            0x06,0x04,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x02,0x00,0x00,0x01,0x00,0x00,0x00, 
            0x77,0x77,0x66,0x66,0x66,0x66,
            0x00,0x00,0x00] 
        lut_partial_only_black = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x01,0x00,0x00,0x00,0x00,0x04, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x88,0x88,0x88,0x88,0x88,0x88,
            0x00,0x00,0x00] 
        lut_partial = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x99, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x01,0x00,0x00,0x00,0x00,0x04, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88, 
            0x00,0x00,0x00]
    elif(temperature < 36):
        Lut_choose = 3
        lut_diff = [
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAA, 
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x99, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x01,0x00,0x00,0x00,0x00,0x03, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88, 
            0x00,0x00,0x00 ]   
        lut_partial_grey = [
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x07,0x05,0x00,0x00,0x00,0x00,0x00,
            0x05,0x04,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x77,0x77,0x77,0x77,0x77,0x77,
            0x00,0x00,0x00 ]
        lut_partial_only_black = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x01,0x00,0x00,0x00,0x00,0x03,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88,
            0x00,0x00,0x00]
        lut_partial = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x99, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x01,0x00,0x00,0x00,0x00,0x03,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x88,0x88,0x88,0x88,0x88,0x88,
            0x00,0x00,0x00]
    else:
        Lut_choose = 4
        lut_diff = [
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0xAA,0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x01,0x00,0x00,0x00,0x00,0x02,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88, 
            0x00,0x00,0x00 ]  
        lut_partial_grey = [
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x80,0x60,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x80,0x88,0x99,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x06,0x04,0x00,0x00,0x00,0x00,0x00,
            0x04,0x04,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x77,0x77,0x77,0x77,0x77,0x77,
            0x00,0x00,0x00] 
        lut_partial_only_black = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x01,0x00,0x00,0x00,0x00,0x02,
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88,
            0x00,0x00,0x00] 
        lut_partial = [
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0xAA,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x99, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x01,0x00,0x00,0x00,0x00,0x02, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x01,0x00,0x00,0x00,0x00,0x00,0x00, 
            0x88,0x88,0x88,0x88,0x88,0x88, 
            0x00,0x00,0x00] 
        

lut_partial_grey = 0
Lut_choose = 0
lut_diff = 0
temperature = 0
update_lut_by_temperature()

wait_busy_check = 1/(60*2)

Analog_activate = False
mode_need_activ_analog = False


### DEBUG - Just for test Code ###
def DEBUG_show_img_test(img):
    for line in range(1,len(img)):
        txt = bin(img[line])[2:]
        for i in range(len(txt), img[0]):
            txt = "0"+txt
        print(txt)
        
    
def DEBUG_convert_hex_to_numb(hex_img, size_x):
    img = [size_x]
    size_x = size_x>>3
    size_cut = (len(hex_img))/size_x
    for line in range(0, size_cut):
        tmp = hex_img[line*size_x: (line+1)*size_x]
        tmp = int.from_bytes(tmp, "big")
        img.append(tmp)
    return img

def print_dev(text):
    if(print_text):
        print(text)
    


 # NUMBER DICO ###    
def reverse_bytes(input_bytes_o, size):
    input_bytes = bytearray(input_bytes_o.to_bytes((size>>3), 'big'))
    reversed_bytes = bytearray(len(input_bytes))
    for i in range(len(input_bytes)):
        byte = input_bytes[i]
        reversed_byte = (
            ((byte & 0x01) << 7) | ((byte & 0x02) << 5) |
            ((byte & 0x04) << 3) | ((byte & 0x08) << 1) |
            ((byte & 0x10) >> 1) | ((byte & 0x20) >> 3) |
            ((byte & 0x40) >> 5) | ((byte & 0x80) >> 7)
        )
        reversed_bytes[len(input_bytes) - i - 1] = reversed_byte
    return int.from_bytes(bytes(reversed_bytes), 'big', False)


# Number sprite
with open("/img/number.json", 'r') as f:
    number_img = load(f)        
dico_nb = {}
for i in range(0, 10):
    for j in range(1, len(number_img[0])):
        number_img[i][j] = reverse_bytes(number_img[i][j],number_img[0][0])
    dico_nb[str(i)] = number_img[i]
size_number = number_img[0][0]
del number_img

# Number sprite 'light'
with open("/img/number_light.json", 'r') as f:
    number_img = load(f)        
dico_nb_light = {}
for i in range(0, 10):
    for j in range(1, len(number_img[0])):
        number_img[i][j] = reverse_bytes(number_img[i][j],number_img[0][0])
    dico_nb_light[str(i)] = number_img[i]
del number_img

# Number sprite inverse
with open("/img/number_inv.json", 'r') as f:
    number_img_inv = load(f)        
dico_nb_inv = {}
for i in range(0, 10):
    dico_nb_inv[str(i)] = number_img_inv[i]
del number_img_inv



class screen_spi:
        
    def __init__(self, clk_pin, mosi_pin , dc_pin, reset_pin, busy_pin, cs_pin, screen_size, frequency=20000000):
        
        self.screen_size = screen_size
        self.spi = SPI(1, baudrate=frequency, polarity=0, phase=0, sck=clk_pin, mosi=mosi_pin)

        self.dc = dc_pin
        self.cs = cs_pin
        self.rst = reset_pin
        self.busy = busy_pin
        
        # Reset Chips on start (said by doc)
        self.reset_display()
        
        self.PILE_RAM_BEFORE = []
        self.PILE_wait_updt_RAM_BEFORE = []
        self.PILE_RAM_NOW = []
        self.buffer_img = [0 for i in range(self.screen_size[1])]
        self.buffer_img_stock_hex = bytearray((self.screen_size[0]>>3)*self.screen_size[1])

        sleep(0.05)
        self.command(0x01,[0x27,0x01,0x01])      # Driver output control (default 0x270100) (here 0x270101)
        self.command(0x3C,[0x80])                # 0x05 BorderWavefrom (default 0xC0)
        self.command(0x21,[0x00,0x80])           # Display update control
        self.command(0x18,[0x80])                # Read built-in temperature sensor
        self.command(0x2C,[0x08])                # Voltage vcom
        self.command(0x03,[0x03])                # Voltage Gate
        self.command(0x04,[0x28,0x28,0x1E])      # Voltage source
        self.command(0x0C,[0xF5,0xF5,0xF5,0x00]) # Booster Soft start Control
        self.command(0x11,[0x03])                # Address mode: top to bottom, left to right
        self.command(0x22,[0x03])  				 # Stop analogue
        self.command(0x45,[0x00,0x00,0x27,0x01]) # Y address range

        self.clean_screen(long = True) # clean screen -> init buffer image to white
        sleep(0.5)
        update_lut_by_temperature() # for re-update temperature after start RPI
        self.configure_lut(lut_partial) # speed screen with lut parameter


    ### Send Data to screen ### 

    # send command we want on screen
    def send_cmd(self, cmd):
        self.dc.value(0)  # command Mode 
        self.cs.value(0)  # select screen
        self.spi.write(bytearray([cmd])) # send
        self.cs.value(1)  # de-select screen

    # data associate to command we send
    def send_data(self, data):
        self.dc.value(1)  # data Mode
        self.cs.value(0)  # select screen
        self.spi.write(data) # send
        self.cs.value(1)  # de-select screen
        
    # init screen (doc says need to make thats)
    def reset_display(self):
        self.rst.value(0)
        sleep(0.2)
        self.rst.value(1)
        sleep(0.2)
    
    def command(self, nam, dat=[]):
        if(not(isinstance(dat, (bytearray)))):
            dat = bytearray(dat)
        if(self.busy.value() == 1):
            start_exc_wit_busy()
        if(nam == 0x20): # Screen Update
            self.execute_all_PILE_ram_now()
            self.execute_all_PILE_ram_before()
            for i in range(len(self.PILE_wait_updt_RAM_BEFORE)): # loop for not saturate RAM !
                self.PILE_RAM_BEFORE.append(self.PILE_wait_updt_RAM_BEFORE.pop(0)) 
        while(self.busy.value() == 1):
            exc_wit_busy()
            sleep(wait_busy_check)
        self.send_cmd(nam)
        if(dat != bytearray([])):
            self.send_data(dat)


    def command_sp_ram(self, nam, dat=[]):
        if(not(isinstance(dat, (bytearray)))):
            dat = bytearray(dat)
        if(self.busy.value() == 1):
            start_exc_wit_busy()
        while(self.busy.value() == 1):
            exc_wit_busy()
            sleep(wait_busy_check)
        self.send_cmd(nam)
        if(dat != bytearray([])):
            self.send_data(dat)


    ### SCREEN UPDATE ###
    def display_update_all(self):
        global Analog_activate
        global mode_need_activ_analog
        self.command(0x22,[0xF7])                # Sequance: load producer-defined LUT and display
        self.command(0x20)                       # Activate Display Update Sequence
        collect()
        Analog_activate = False
        mode_need_activ_analog = False
        
    def display_black(self):
        global Analog_activate
        global mode_need_activ_analog
        self.command(0x32,lut_black)             # Load user-defined LUT for black-only display
        self.command(0x22,[0xC7])                # Sequence: display
        self.command(0x20)                       # Activate Display Update Sequence
        collect()
        Analog_activate = False
        mode_need_activ_analog = False
        
    def display_clean(self):
        global Analog_activate
        global mode_need_activ_analog
        if(not(Analog_activate)):
            self.enable_analog()
        self.command(0x32,lut_clean)             # Load user-defined LUT for clean display
        self.command(0x22,[0x04])                # Sequence: display
        self.command(0x20)                       # Activate Display Update Sequence
        collect()
        mode_need_activ_analog = True

    def display_long_clean(self):
        global Analog_activate
        global mode_need_activ_analog
        if(not(Analog_activate)):
            self.enable_analog()
        self.command(0x22,[0xF7])                # Sequence: display
        self.command(0x20)                       # Activate Display Update Sequence
        collect()
        mode_need_activ_analog = True
        Analog_activate = False

    def display_partial(self, only_black = False):
        global Analog_activate
        global mode_need_activ_analog
        if(not(Analog_activate)):
            self.enable_analog()
        if(only_black):
            self.command(0x32,lut_partial_only_black)           # Load user-defined LUT for partial refresh
        else:
            self.command(0x32,lut_partial)           			# Load user-defined LUT for partial refresh
        self.command(0x22,[0x04])                				# Sequence: display
        self.command(0x20)                       				# Activate Display Update Sequence
        collect()
        mode_need_activ_analog = True
        
        
    def display_grey(self):
        global Analog_activate
        global mode_need_activ_analog
        if(not(Analog_activate)):
            self.enable_analog()
        self.command(0x32,lut_partial_grey)           			# Load user-defined LUT for partial refresh
        self.command(0x22,[0x04])                				# Sequence: display
        self.command(0x20)                       				# Activate Display Update Sequence
        collect()
        mode_need_activ_analog = True

        
    def display_diff(self):
        global Analog_activate
        global mode_need_activ_analog
        if(not(Analog_activate)):
            self.enable_analog()
        t = monotonic()
        self.command(0x32,lut_diff)           # Load user-defined LUT for partial refresh
        self.command(0x22,[0x04])             # Sequence: display
        self.command(0x20)                    # Activate Display Update Sequence
        collect()
        mode_need_activ_analog = True
        print_dev("#--- UPDATE SCREEN %s miliseconds ---" % ((monotonic() - t)*1000))

    def display_already_lut(self):
        global Analog_activate
        global mode_need_activ_analog
        if(not(Analog_activate) and mode_need_activ_analog):
            self.enable_analog()
        t = monotonic()
        self.command(0x20)                       # Activate Display Update Sequence
        collect()
        print_dev("#--- UPDATE SCREEN %s miliseconds ---" % ((monotonic() - t)*1000))

    def disable_analog(self, sleep_time = 0):
        global Analog_activate
        self.command(0x22,[0x03]) # Sequence: display
        self.command_sp_ram(0x20)
        Analog_activate = False

    def enable_analog(self):
        global Analog_activate
        self.command(0x22,[0xC0]) # Sequence: display
        self.command_sp_ram(0x20)
        Analog_activate = True
        
    def configure_lut(self, lut):
        self.command(0x32,lut)         
        
    def go_in_lut_diff(self):
        self.command(0x32,lut_diff)
        
    def go_in_lut_partial(self):
        self.command(0x32,lut_partial)

    def buffer_all_white(self):
        v = 2**(self.screen_size[0]) -1
        for i in range(self.screen_size[1]):
            self.buffer_img[i] = v
        v = 0

    def clean_screen(self, quick = False, long = False):
        # Set windows all screen
        # Reinitialise buffer and generate hex value
        PILE_RAM_BEFORE = []
        PILE_RAM_NOW = []
        PILE_wait_updt_RAM_BEFORE = []
        self.buffer_all_white()
        collect()

        self.write_all_screen(hex_value = [0xFF])
        collect()        
        if(quick):
            self.display_clean()
        elif(long):
            self.display_long_clean()
        else:
            self.display_update_all()
        
        
    ### BASIC FUNCTION IMAGE ###       
    def move_x_img(self, img, move, left = True):
        start_time_t = monotonic()
        for line in range(1,len(img)):
            if(left):
                img[line] = img[line]<<move
            else:
                img[line] = img[line]>>move
        if(left):
            img[0] += move
        else:
            img[0] -= move
        return img
                
    def get_part_of_bytes(self, image, image_size, pos, size):
        end_move = image_size - pos[0] - size[0]
        get_elem = 2**size[0]-1
        image = image[pos[1]: pos[1] + size[1]]
        if(end_move > 0):
            for line in range(0,size[1]):
                image[line] = (image[line]>>end_move)&get_elem
        else:
            for line in range(0,size[1]):
                image[line] = (image[line]<<(-end_move))&get_elem    
        return image
    
    def merge_two_img(self, img1_0, img2_o):
        img1 = img1_0.copy()
        img2 = img2_o.copy()
        img1[0] += img2[0]
        for line in range(1, len(img1)):
            img1[line] = ((img1[line])<<(img2[0])) + img2[line]
        return img1
        
    # Run on load of image for decrease size of img if possible
    def pre_optimise_img(self, img_list):
        config_img_opti = []
        img_list_opti = []
        for img in img_list:
            pos = [0, 0]
            # Cut transparency on img y
            index_start = 1
            while(img[index_start] == 0):
                index_start += 1
            index_end = len(img)-1
            while(img[index_end] == 0):
                index_end -= 1
            img = [img[0]] + img[index_start:index_end+1]
            pos[1] += index_start-1
            # Cut transparency on img x
            total_val = 0
            index_start = -1
            while(total_val== 0):
                index_start += 1
                total_val = 0
                for i in range(1, len(img)):
                    total_val += ((img[i]>>(img[0]-1-index_start))&1)
            img[0] -= index_start
    
            total_val = 0
            index_end = img[0]
            while(total_val== 0):
                index_end -= 1
                total_val = 0
                for i in range(1, len(img)):
                    total_val += ((img[i]>>(img[0]-index_end))&1)
            img[1:] = self.get_part_of_bytes(img[1:], img[0], [0,0], [index_end, len(img)-1])
            pos[0] += (img[0] - index_end)
            img[0] = index_end
            
            img_list_opti.append(img)
            config_img_opti.append(pos)
        return img_list_opti, config_img_opti

        
    ### IMAGE PROCESS DETAIL ###           
    def realign_img(self, img, pos):
        # Cut y img part not on screen
        if(pos[1] < 0):
            img = [img[0]] + img[1-pos[1]:]
            pos[1] = 0
        if(pos[1] + len(img)-1 > self.screen_size[1]):
            img = img[:1+self.screen_size[1] - pos[1]]
        # Cut x img part not on screen
        if(pos[0] < 0):
            img[1:] = self.get_part_of_bytes(img[1:], img[0], [abs(pos[0]),0], [img[0]+pos[0], len(img)-1])
            img[0] += pos[0]
            pos[0] = 0
        end_screen = self.screen_size[0] - pos[0] - img[0]
        if(end_screen < 0):
            img = self.move_x_img(img, abs(end_screen), left = False)
    
        return img, pos


    def insert_buffer_image(self, realign_table, pos, erase = False):
        sign = 1
        y_img = 0
        # Lines of
        end_move = self.screen_size[0] - pos[0] - realign_table[0]
        # Add bytes for insert in buffer image
        tmp_mg = self.move_x_img(realign_table, abs(end_move), left = end_move>=0)
        # Add to buffer images
        for i in range(0, len(realign_table)-1):
            if(not(erase)):
                self.buffer_img[pos[1]+i] = self.buffer_img[pos[1]+ i] & (~tmp_mg[i+1])
            else:
                self.buffer_img[pos[1]+i] = self.buffer_img[pos[1]+ i] | tmp_mg[i+1]
        return 
    
    
    def get_buffer_part(self, pos, shape):
        # pos to multiply of 8 (lower pos)
        pos_x_corrected = ((pos[0]>>3)<<3)
        shape[0] += (pos[0] - pos_x_corrected)%8 # add value pos diff on size
        pos[0] = pos_x_corrected
        # Size multiple of 8 (higter size)
        shape[0] += ((((shape[0]>>3)+1)<<3) - shape[0])%8
        
        img_buff_now = self.get_part_of_bytes(self.buffer_img, self.screen_size[0], pos, shape)
        
        return img_buff_now, pos, shape


    def convert_hex_img(self, image_buff, size_x):
        size_arr = (size_x>>3) # size of hex array -> just divide size by 8
        hexa_value = bytearray(size_arr*len(image_buff))
        offset = 0
        for line in range(0,len(image_buff)):
            hexa_value[offset:offset+size_arr] = image_buff[line].to_bytes(size_arr, 'big') # convert
            offset += size_arr
        return hexa_value
    
    def convert_hex_all_buffer_img(self):
        offset = 0
        size_arr = (self.screen_size[0]>>3)
        for line in range(0,self.screen_size[1]):
            self.buffer_img_stock_hex[offset:offset+size_arr] = self.buffer_img[line].to_bytes(size_arr, 'big')
            offset += size_arr

    def windows_ram_for_img(self, pos, shape):
        # change windows of write memory
        x_result = bytearray([(pos[0]>>3), (pos[0]>>3)+(shape[0]>>3)-1])
        
        self.command(0x44,x_result) 		# X address range

        pos_y_end = pos[1] + shape[1]-1
        y_result = [0, 0]#, 0, 0]
        if(pos[1]>>8 == 0): y_result[0] = pos[1]
        else:
            y_result[0] = pos[1] - 256
            y_result[1] = 1
        y_result = bytearray(y_result)

        self.command(0x4E,[x_result[0]])                # X address start
        self.command(0x4F,[y_result[0],y_result[1]])    # Y address start

        return x_result, y_result
    
    
    def windows_ram_for_img_sp_ram_before(self, pos, shape):
        # change windows of write memory
        x_result = bytearray([(pos[0]>>3), (pos[0]>>3)+(shape[0]>>3)-1])
        
        self.command_sp_ram(0x44,x_result) 		# X address range

        pos_y_end = pos[1] + shape[1]-1
        y_result = [0, 0]
        if(pos[1]>>8 == 0): y_result[0] = pos[1]
        else:
            y_result[0] = pos[1] - 256
            y_result[1] = 1
        y_result = bytearray(y_result)

        self.command_sp_ram(0x4E,[x_result[0]])                # X address start
        self.command_sp_ram(0x4F,[y_result[0],y_result[1]])    # Y address start

        return x_result, y_result


    ### IMAGE PROCESS GENERALE ###           
    def write_img_ram(self, img_original, pos_original, erase = False, ram_now = True, ram_before = True, ram_red_after_upd = False):

        print_dev("write on ram " + "Ram Now : " + str(ram_now) + " ### Ram Before : " + str(ram_before))
        t_total = 0
        t = monotonic()
        # Copy table for not modif directly
        img = img_original.copy()
        pos = pos_original.copy()
        pos[0] = self.screen_size[0] - pos[0] - img[0]
        
        print_dev("#--- COPY %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        # align image for enter in buffer -> cut outside screen
        img, pos = self.realign_img(img, pos)
        print_dev("#--- REALIGN %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        # add on image buffer and get buffer cut by 8 on x 
        self.insert_buffer_image(img, pos, erase)
        print_dev("#--- INSERT BUFFER %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        
        if(ram_now or ram_before): # if not -> info not send to screen, only on buffer
            t = monotonic()
            img, pos, shape = self.get_buffer_part(pos, [img[0], len(img)-1])
            print_dev("#--- GET BUFFER %s miliseconds ---" % ((monotonic() - t)*1000))
            t_total += (monotonic() - t)*1000
            t = monotonic()
             # convert image to hex value
            img = self.convert_hex_img(img, shape[0])
        
            print_dev("#--- CONVERT HEX %s miliseconds ---" % ((monotonic() - t)*1000))
            t_total += (monotonic() - t)*1000
            
        t = monotonic()
        # Write to RAM Black
        if(ram_now):
            self.PILE_RAM_NOW.append([img, pos, shape])
            self.try_execute_PILE_ram_now()
            print_dev("#--- RAM Black %s miliseconds ---" % ((monotonic() - t)*1000))
            t_total += (monotonic() - t)*1000
            t = monotonic()

        # Write to RAM Red (Used Like Buffer previous Frame)
        if(ram_before):
            if(not(ram_red_after_upd)):
                self.PILE_RAM_BEFORE.append([img, pos, shape])
            else:
                self.PILE_wait_updt_RAM_BEFORE.append([img, pos, shape])
            self.try_execute_PILE_ram_before()
            print_dev("#--- RAM RED %s miliseconds ---" % ((monotonic() - t)*1000))
            t_total += (monotonic() - t)*1000
            
        img = 0
        pos = 0
        print_dev("#--- TOTAL (whitout Hex test) %s miliseconds ---" % (t_total))
        return


    def write_img_ram_hex_img(self, img_hex, ram_now = True, ram_before = True):
        self.command(0x44,[0x00,0x0F])           # X address range
        
        if(ram_now):
            self.command(0x4E,[0x00])                # X address start
            self.command(0x4F,[0x00,0x00])			 # Y address start
            self.command(0x24 ,img_hex) # write image to memory
        
        # Ram Red -> Used Like Buffer
        if(ram_before):
            self.command(0x4E,[0x00])                # X address start
            self.command(0x4F,[0x00,0x00])			 # Y address start
            self.command(0x26,img_hex) 			# write image to memory
        
        PILE_RAM_BEFORE = []
        PILE_RAM_NOW = []
        PILE_wait_updt_RAM_BEFORE = []



    def write_all_screen(self, ram_now = True, ram_before = True, hex_value = []):
        # Lot of problem of out of memory with this function
        # so it's just write screen by a fixed number, we send information on 4 times for not create at big table of value
        # Hex conversion if need is process on 6 parts (during hex process, lot of memory is used), i thing the best is send hex during
        # but finaly I dont use this so i optimise memory of this the day of i need to use it
        collect()
        self.command(0x44,[0x00,0x0F])           # X address range

        if(len(hex_value) == 0):
            # Problem memory
            hex_value = self.convert_hex_img(self.buffer_img[0:50], self.screen_size[0])
            collect()
            hex_value.extend(self.convert_hex_img(self.buffer_img[50:100], self.screen_size[0]))
            collect()
            hex_value.extend(self.convert_hex_img(self.buffer_img[100:150], self.screen_size[0]))
            collect()
            hex_value.extend(self.convert_hex_img(self.buffer_img[150:200], self.screen_size[0]))
            collect()
            hex_value.extend(self.convert_hex_img(self.buffer_img[200:250], self.screen_size[0]))
            collect()
            hex_value.extend(self.convert_hex_img(self.buffer_img[250:], self.screen_size[0]))
            collect()
        
        # Ram Black
        if(ram_now):
            self.command(0x4E,[0x00])                # X address start
            self.command(0x4F,[0x00,0x00])			 # Y address start
            if(len(hex_value) == 1):
                if(hex_value == [0xFF]):
                    self.command(0x47, [0xFF]) # Autowrite white by screen function
                else: # Never use but work, maybe one day i need to update form of hex repeat
                    hex_value_send = bytearray(hex_value[0] for i in range(int((self.screen_size[1] * self.screen_size[0]/8)/4)))
                    for i in range(4):
                        self.command(0x24 ,hex_value_send) # write image to memory
                    del hex_value_send
            else:
                self.command(0x24 ,hex_value) # write image to memory
  
        
        # Ram Red -> Used Like Buffer
        if(ram_before):
            self.command(0x4E,[0x00])                # X address start
            self.command(0x4F,[0x00,0x00])			 # Y address start
            if(len(hex_value) == 1):
                if(hex_value == [0xFF]):
                    self.command(0x46, [0xFF]) # Autowrite white by screen function
                else:
                    hex_value_send = bytearray(hex_value[0] for i in range(int((self.screen_size[1] * self.screen_size[0]/8)/4)))
                    for i in range(4):
                        self.command(0x26 ,hex_value_send) # write image to memory
                    del hex_value_send
            else:
                self.command(0x26 ,hex_value) # write image to memory
        
        PILE_RAM_BEFORE = []
        PILE_RAM_NOW = []
        PILE_wait_updt_RAM_BEFORE = []



    def update_img_screen(self, img_original, pos_original, erase = False, already_lut = False):
        ''' Update Image Screen With delta value between two frame of update '''
        t_total = 0
        t = monotonic()
        # Copy table for not modif directly
        img = img_original.copy()
        pos = pos_original.copy()
        pos[0] = self.screen_size[0] - pos[0] - img[0]
        print_dev("#--- COPY %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        # align image for enter in buffer -> cut outside screen
        img, pos = self.realign_img(img, pos)
        print_dev("#--- REALIGN %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        # add on image buffer and get buffer cut by 8 on x 
        self.insert_buffer_image(img, pos, erase)
        print_dev("#--- INSERT BUFFER %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        img, pos, shape = self.get_buffer_part(pos, [img[0], len(img)-1])
        print_dev("#--- GET BUFFER %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
         # convert image to hex value
        img = self.convert_hex_img(img, shape[0])
        
        print_dev("#--- CONVERT HEX %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        
        #### TEST IF HEX IS OK ####
        if(debug_mode and not(Test_only_speed)):
            recreate_img = DEBUG_convert_hex_to_numb(img, shape[0])
            DEBUG_show_img_test(recreate_img)
            print_dev("#--- TEST HEX %s miliseconds ---" % ((monotonic() - t)*1000))
            t = monotonic()
        ###########################

        # Write to RAM Black
        self.PILE_RAM_NOW.append([img, pos, shape])
        self.try_execute_PILE_ram_now()
        print_dev("#--- RAM Black %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()
        
        # Update Screen on Diff
        if(already_lut): self.display_already_lut()
        else: self.display_diff() #display_diff
        print_dev("#--- UPDATE SCREEN %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        t = monotonic()                
        
        # Write to RAM Red (Used Like Buffer previous Frame)
        self.PILE_RAM_BEFORE.append([img, pos, shape])
        self.try_execute_PILE_ram_before()

        print_dev("#--- RAM RED %s miliseconds ---" % ((monotonic() - t)*1000))
        t_total += (monotonic() - t)*1000
        
        img = 0
        pos = 0
        print_dev("#--- TOTAL (whitout Hex test) %s miliseconds ---" % (t_total))

    def delete_and_update_img_screen(self, img_del_original, pos_del_original, img_add_original, pos_add_original, already_lut = False):
        ''' Update Image Screen With delta value between two frame of update '''
        t = monotonic()
        # Copy table for not modif directly
        img_del = img_del_original.copy()
        pos_del = pos_del_original.copy()
        pos_del[0] = self.screen_size[0] - pos_del[0] - img_del[0]


        img_add = img_add_original.copy()
        pos_add = pos_add_original.copy()
        pos_add[0] = self.screen_size[0] - pos_add[0] - img_add[0]

        # ERASE RAM -> Black
        img_del, pos_del = self.realign_img(img_del, pos_del)
        self.insert_buffer_image(img_del, pos_del, erase = True)
        img_del, pos_del, shape_del = self.get_buffer_part(pos_del, [img_del[0], len(img_del)-1])
        img_del = self.convert_hex_img(img_del, shape_del[0]) # convert image to hex value
        
        self.PILE_RAM_NOW.append([img_del, pos_del, shape_del])
        self.try_execute_PILE_ram_now()

        # ADD RAM -> Black
        img_add, pos_add = self.realign_img(img_add, pos_add)
        self.insert_buffer_image(img_add, pos_add, erase = False)
        img_add, pos_add, shape_add = self.get_buffer_part(pos_add, [img_add[0], len(img_add)-1])
        img_add = self.convert_hex_img(img_add, shape_add[0]) # convert image to hex value
        
        self.PILE_RAM_NOW.append([img_add, pos_add, shape_add])
        self.try_execute_PILE_ram_now()

        # Update Screen on Diff
        if(already_lut): self.display_already_lut()
        else: self.display_diff() #self.display_diff()
        
        self.PILE_RAM_BEFORE.append([img_del, pos_del, shape_del])
        self.PILE_RAM_BEFORE.append([img_add, pos_add, shape_add])
        
        img_del = 0
        pos_del = 0
        img_add = 0
        pos_add = 0
        print_dev("#--- TOTAL %s miliseconds ---" % ((monotonic() - t)*1000))



    def write_number(self, number, pos, inverse = False, erase_before = True, already_lut = False, only_write = False, ram_now = True, ram_before = True, write_white_on_ram_before = False, ram_red_after_upd = False, light_txt = False):
        start_time = monotonic()

        # Create "Image" of Number
        number = str(number)
        
        if(inverse):
            size = len(dico_nb_inv["0"])-1
            img = [0 for i in range(0, size*len(number))]
            i = 0
            img[0] = dico_nb_inv["0"][0]
            for c in number:
                img[1+(len(number) - i -1)*size:1+(len(number) - i)*size] = dico_nb_inv[c][1:]
                i+=1
        else:
            if(light_txt):
                img = [0 for i in range(0, len(dico_nb_light["0"]))]
                for c in number:
                    img_c = dico_nb_light[c]
                    img = self.merge_two_img(img_c, img)
            else:
                img = [0 for i in range(0, len(dico_nb["0"]))]
                for c in number:
                    img_c = dico_nb[c]
                    img = self.merge_two_img(img_c, img)
            
        # Erase in buffer zone of futur Number (not on RAM of screen)
        if(erase_before):
            erase_img = [img[0]] + [(2**img[0])-1 for i in range(1, len(img))]
            erase_pos = [self.screen_size[0] - pos[0] - img[0],  pos[1]]
            self.insert_buffer_image(erase_img, erase_pos, erase = True)

        if(not(only_write)):
            # Update image number -> By Difference
            self.update_img_screen(img, pos, erase = False, already_lut = already_lut)
        else:
            if(not(write_white_on_ram_before)):
                self.write_img_ram(img, pos, erase = False, ram_now = ram_now, ram_before = ram_before, ram_red_after_upd = ram_red_after_upd)
            else: # write empty image on before and a ok image now
                erase_img = [img[0]] + [0 for i in range(1, len(img))] #(2**img[0])-1
                self.write_img_ram(erase_img, pos, erase = True, ram_now = False, ram_before = True, ram_red_after_upd = False)
                self.write_img_ram(img, pos, erase = False, ram_now = ram_now, ram_before = ram_before, ram_red_after_upd = ram_red_after_upd)

        print_dev("--- WRITE NUMBER %s miliseconds ---" % ((monotonic() - start_time)*1000))
        print_dev(f"Memory: {mem_alloc()} of {mem_free()} bytes used.")

    def try_execute_PILE_ram_before(self):
        if(len(self.PILE_RAM_BEFORE) >= 1 and not(self.busy.value() == 1)):
            elem = self.PILE_RAM_BEFORE.pop(0)
            self.windows_ram_for_img_sp_ram_before(elem[1], elem[2])      
            self.command_sp_ram(0x26, elem[0]) # write image to memory
            
    def try_execute_PILE_ram_now(self):
        if(len(self.PILE_RAM_NOW) >= 1 and not(self.busy.value() == 1)):
            elem = self.PILE_RAM_NOW.pop(0)
            self.windows_ram_for_img_sp_ram_before(elem[1], elem[2])      
            self.command_sp_ram(0x24, elem[0]) # write image to memory

    def execute_all_PILE_ram_before(self):
        for i in range(len(self.PILE_RAM_BEFORE)):
            self.windows_ram_for_img_sp_ram_before(self.PILE_RAM_BEFORE[i][1], self.PILE_RAM_BEFORE[i][2])      
            self.command_sp_ram(0x26, self.PILE_RAM_BEFORE[i][0]) # write image to memory
        self.PILE_RAM_BEFORE = []

    def execute_all_PILE_ram_now(self):
        for i in range(len(self.PILE_RAM_NOW)):
            self.windows_ram_for_img_sp_ram_before(self.PILE_RAM_NOW[i][1], self.PILE_RAM_NOW[i][2])      
            self.command_sp_ram(0x24, self.PILE_RAM_NOW[i][0]) # write image to memory
        self.PILE_RAM_NOW = []
   
   
# init Screen
cs_pin = Pin(13, Pin.OUT)
dc_pin = Pin(12, Pin.OUT)
reset_pin = Pin(15, Pin.OUT)
busy_pin = Pin(14, Pin.IN)
mosi_pin = Pin(11, Pin.OUT)
clk_pin = Pin(10, Pin.OUT)
screen_size = { "height" : 296, "width" :128 }

display = screen_spi(clk_pin, mosi_pin , dc_pin, reset_pin, busy_pin, cs_pin, (screen_size["width"], screen_size["height"]))


if(debug_mode): # Only use for check speed and good working of code

    with open("/img/Climber/guy_multi.json", 'r') as f:
        test = load(f)        
    temp = test[0]

    print_dev(f"Memory: {mem_alloc()} of {mem_free()} bytes used.")

    display.enable_analog()

    #screen.enable_analog()
    previous_x_y = []
    
    for i in range(10):
        for y in ([0, 80, 120, 200, 250]):
            for x in ([0, 30, 80, 110]):
                print_dev(f"########### STARTING ADD ###########.")
                start_time_i = monotonic()
                if(previous_x_y == []):
                    display.update_img_screen(temp, [x, y], erase = False)
                else:
                    display.delete_and_update_img_screen(temp, previous_x_y, temp, [x, y], already_lut = True)
                previous_x_y = [x, y].copy()
                print_dev("--- RESULT %s miliseconds ---" % ((monotonic() - start_time_i)*1000))
                print_dev("--- %s seconds ---" % ((monotonic() - start_time_i)))
                print_dev("--- %s FPS ---" % (int(1/(monotonic() - start_time_i))))

                print_dev(f"Memory: {mem_alloc()} of {mem_free()} bytes used.")
    if(not(Test_only_speed)):
        DEBUG_show_img_test([display.screen_size[0]]+display.buffer_img)
        
    display.clean_screen() 
